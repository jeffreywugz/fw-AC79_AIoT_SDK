//小蜂管家
//你好小蜂
//小蜂你好
//小蜂小蜂
//小艾小艾
//小乐小乐
//小美小美
//小智小智
//小佳小佳
//小优小优
//小可小可
//会客模式
//用餐模式
//休息模式
//影音模式
//娱乐模式
//起夜模式
//会议模式
//投影模式
//离开模式
//派对模式
//回家模式
//打开窗帘
//关闭窗帘
//停止窗帘
//打开灯光
//关闭灯光
//调亮灯光
//调暗灯光
//调到白光
//调到黄光
//调到自然光
//打开空调
//关闭空调
//调高温度
//调低温度
//制冷模式
//加热模式
//通风模式
//除湿模式
//最小风量
//中等风量
//最大风量
//自动风量
//上下摆风
//左右摆风
//快捷配网
//打开语音
//关闭语音
//打开播报
//关闭播报
static const unsigned char result0[13] = {0xE5, 0xB0, 0x8F, 0xE8, 0x9C, 0x82, 0xE7, 0xAE, 0xA1, 0xE5, 0xAE, 0xB6, 0x00}; //小蜂管家
static const unsigned char result3[13] = {0xE5, 0xB0, 0x8F, 0xE8, 0x9C, 0x82, 0xE5, 0xB0, 0x8F, 0xE8, 0x9C, 0x82, 0x00}; //小蜂小蜂
static const unsigned char result4[13] = {0xE4, 0xBC, 0x9A, 0xE5, 0xAE, 0xA2, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //会客模式
static const unsigned char result5[13] = {0xE7, 0x94, 0xA8, 0xE9, 0xA4, 0x90, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //用餐模式
static const unsigned char result6[13] = {0xE4, 0xBC, 0x91, 0xE6, 0x81, 0xAF, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //休息模式
static const unsigned char result7[13] = {0xE5, 0xBD, 0xB1, 0xE9, 0x9F, 0xB3, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //影音模式
static const unsigned char result8[13] = {0xE5, 0xA8, 0xB1, 0xE4, 0xB9, 0x90, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //娱乐模式
static const unsigned char resultc[13] = {0xE7, 0xA6, 0xBB, 0xE5, 0xBC, 0x80, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //离开模式
static const unsigned char resulte[13] = {0xE5, 0x9B, 0x9E, 0xE5, 0xAE, 0xB6, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //回家模式
static const unsigned char resultf[13] = {0xE6, 0x89, 0x93, 0xE5, 0xBC, 0x80, 0xE7, 0xAA, 0x97, 0xE5, 0xB8, 0x98, 0x00}; //打开窗帘
static const unsigned char result10[13] = {0xE5, 0x85, 0xB3, 0xE9, 0x97, 0xAD, 0xE7, 0xAA, 0x97, 0xE5, 0xB8, 0x98, 0x00}; //关闭窗帘
static const unsigned char result11[13] = {0xE5, 0x81, 0x9C, 0xE6, 0xAD, 0xA2, 0xE7, 0xAA, 0x97, 0xE5, 0xB8, 0x98, 0x00}; //停止窗帘
static const unsigned char result12[13] = {0xE5, 0xB0, 0x8F, 0xE8, 0x9C, 0x82, 0xE5, 0xBC, 0x80, 0xE7, 0x81, 0xAF, 0x00}; //小蜂开灯
static const unsigned char result13[13] = {0xE5, 0xB0, 0x8F, 0xE8, 0x9C, 0x82, 0xE5, 0x85, 0xB3, 0xE7, 0x81, 0xAF, 0x00}; //小蜂关灯
static const unsigned char result16[13] = {0xE8, 0xB0, 0x83, 0xE4, 0xBA, 0xAE, 0xE4, 0xB8, 0x80, 0xE7, 0x82, 0xB9, 0x00}; //调亮一点
static const unsigned char result17[13] = {0xE8, 0xB0, 0x83, 0xE6, 0x9A, 0x97, 0xE4, 0xB8, 0x80, 0xE7, 0x82, 0xB9, 0x00}; //调暗一点
static const unsigned char result18[13] = {0xE6, 0x89, 0x93, 0xE5, 0xBC, 0x80, 0xE7, 0xA9, 0xBA, 0xE8, 0xB0, 0x83, 0x00}; //打开空调
static const unsigned char result19[13] = {0xE5, 0x85, 0xB3, 0xE9, 0x97, 0xAD, 0xE7, 0xA9, 0xBA, 0xE8, 0xB0, 0x83, 0x00}; //关闭空调
static const unsigned char result1b[13] = {0xE8, 0xB0, 0x83, 0xE9, 0xAB, 0x98, 0xE6, 0xB8, 0xA9, 0xE5, 0xBA, 0xA6, 0x00}; //调高温度
static const unsigned char result1d[13] = {0xE8, 0xB0, 0x83, 0xE4, 0xBD, 0x8E, 0xE6, 0xB8, 0xA9, 0xE5, 0xBA, 0xA6, 0x00}; //调低温度
static const unsigned char result1e[13] = {0xE5, 0x88, 0xB6, 0xE5, 0x86, 0xB7, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //制冷模式
static const unsigned char result1f[13] = {0xE5, 0x8A, 0xA0, 0xE7, 0x83, 0xAD, 0xE6, 0xA8, 0xA1, 0xE5, 0xBC, 0x8F, 0x00}; //加热模式
static const unsigned char result22[13] = {0xE6, 0x9C, 0x80, 0xE5, 0xB0, 0x8F, 0xE9, 0xA3, 0x8E, 0xE9, 0x87, 0x8F, 0x00}; //最小风量
static const unsigned char result23[13] = {0xE4, 0xB8, 0xAD, 0xE7, 0xAD, 0x89, 0xE9, 0xA3, 0x8E, 0xE9, 0x87, 0x8F, 0x00}; //中等风量
static const unsigned char result24[13] = {0xE6, 0x9C, 0x80, 0xE5, 0xA4, 0xA7, 0xE9, 0xA3, 0x8E, 0xE9, 0x87, 0x8F, 0x00}; //最大风量
static const unsigned char result25[13] = {0xE8, 0x87, 0xAA, 0xE5, 0x8A, 0xA8, 0xE9, 0xA3, 0x8E, 0xE9, 0x87, 0x8F, 0x00}; //自动风量
static const unsigned char result26[13] = {0xE6, 0x89, 0x93, 0xE5, 0xBC, 0x80, 0xE6, 0x91, 0x86, 0xE9, 0xA3, 0x8E, 0x00}; //打开摆风
static const unsigned char result27[13] = {0xE4, 0xB8, 0x8A, 0xE4, 0xB8, 0x8B, 0xE6, 0x91, 0x86, 0xE9, 0xA3, 0x8E, 0x00}; //上下摆风
static const unsigned char result28[13] = {0xE5, 0xB7, 0xA6, 0xE5, 0x8F, 0xB3, 0xE6, 0x91, 0x86, 0xE9, 0xA3, 0x8E, 0x00}; //左右摆风
static const unsigned char result29[13] = {0xE5, 0x85, 0xB3, 0xE9, 0x97, 0xAD, 0xE6, 0x91, 0x86, 0xE9, 0xA3, 0x8E, 0x00}; //关闭摆风

#include "server/audio_server.h"
#include "server/server_core.h"
#include "generic/circular_buf.h"
#include "fs/fs.h"
#include "os/os_api.h"
#include "fn_asr.h"
#include "event.h"
#include "app_config.h"

#if (defined CONFIG_ASR_ALGORITHM) && (CONFIG_ASR_ALGORITHM == WANSON_ALGORITHM)

#if defined CONFIG_VIDEO_ENABLE || defined CONFIG_NO_SDRAM_ENABLE
#define WANSON_DUAL_MIC_ALGORITHM    0   //0选择单mic/1选择双mic算法
#else
#define WANSON_DUAL_MIC_ALGORITHM    1   //0选择单mic/1选择双mic算法
#endif

#define DISABLE_AEC_CHANNEL          1

#if DISABLE_AEC_CHANNEL
#define CONFIG_AISP_DIFFER_MIC_REPLACE_LINEIN
#endif

#if CONFIG_AUDIO_ENC_SAMPLE_SOURCE != AUDIO_ENC_SAMPLE_SOURCE_MIC

#ifdef CONFIG_AISP_DIFFER_MIC_REPLACE_LINEIN
#define CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN_OTHER
#endif
#undef CONFIG_AISP_DIFFER_MIC_REPLACE_LINEIN

#else

#ifdef CONFIG_AISP_DIFFER_MIC_REPLACE_LINEIN
#define CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
#endif

#endif

#define ONCE_SR_POINTS	480
#define WANSON_BUF_SIZE	(4 * ONCE_SR_POINTS)	//跑不过来时适当加大倍数

#define PCM_TEST_MODE_0                0   //测试模式0，会发送当前音频给电脑
#define PCM_TEST_MODE_1                1   //测试模式1，会发唤醒时当前缓存音频给电脑

#define WIFI_PCM_STREAN_TEST       PCM_TEST_MODE_0

static struct {
    int pid;
    u32 sample_rate;
    int volatile run_flag;
    OS_SEM sem;
#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
    void *linein_enc;
    cbuffer_t linein_cbuf;
    s16 linein_buf[WANSON_BUF_SIZE];
    s16 mic_buf[WANSON_BUF_SIZE * (1 + WANSON_DUAL_MIC_ALGORITHM)];
#else
    s16 mic_buf[WANSON_BUF_SIZE * (2 + WANSON_DUAL_MIC_ALGORITHM - DISABLE_AEC_CHANNEL)];
#endif
    void *mic_enc;
    cbuffer_t mic_cbuf;
#if defined WIFI_PCM_STREAN_SOCKET_ENABLE && !DISABLE_AEC_CHANNEL
    cbuffer_t aec_cbuf;
    s16 aec_buf[WANSON_BUF_SIZE];
    short send_buf[ONCE_SR_POINTS * 4];
#endif
#if !defined CONFIG_NO_SDRAM_ENABLE && !DISABLE_AEC_CHANNEL
    cbuffer_t asr_cbuf;
    s16 asr_buf[WANSON_BUF_SIZE];
    OS_SEM asr_sem;
#endif
} wanson_server;

#define __this (&wanson_server)

static void wanson_task(void *priv)
{
    short buf[ONCE_SR_POINTS * (2 + WANSON_DUAL_MIC_ALGORITHM - DISABLE_AEC_CHANNEL)];
    u32 mic_len, linein_len;
    const char *text = NULL;
    float score = 0;

    if (Wanson_ASR_Init()) {
        return;
    }
    Wanson_ASR_Reset();

    printf("wanson asr start OK \n");

    while (1) {
        if (!__this->run_flag) {
            os_sem_pend(&__this->sem, 0);
            continue;
        }

#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
        if ((cbuf_get_data_size(&__this->mic_cbuf) < ONCE_SR_POINTS * 2 * (WANSON_DUAL_MIC_ALGORITHM + 1))
            || (cbuf_get_data_size(&__this->linein_cbuf) < ONCE_SR_POINTS * 2)) {
            os_sem_pend(&__this->sem, 0);
            continue;
        }
        short tempbuf[ONCE_SR_POINTS * (2 + WANSON_DUAL_MIC_ALGORITHM)];
        mic_len = cbuf_read(&__this->mic_cbuf, tempbuf, ONCE_SR_POINTS * 2 * (WANSON_DUAL_MIC_ALGORITHM + 1));
        if (!mic_len) {
            continue;
        }
        linein_len = cbuf_read(&__this->linein_cbuf, (u8 *)tempbuf + mic_len, ONCE_SR_POINTS * 2);
        if (!linein_len) {
            continue;
        }

        mic_len /= 2;
        //重组数据
        for (u32 i = 0, j = 0; j < ONCE_SR_POINTS; ++j) {
#if WANSON_DUAL_MIC_ALGORITHM
            buf[i++] = tempbuf[j * 2];
            buf[i++] = tempbuf[j * 2 + 1];
#else
            buf[i++] = tempbuf[j];
#endif
            buf[i++] = tempbuf[mic_len + j];
        }

#else

        mic_len = cbuf_read(&__this->mic_cbuf, buf, sizeof(buf));
        if (!mic_len) {
            os_sem_pend(&__this->sem, 0);
            continue;
        }
#if 0	//如果回采通道采用AD1需要打开此宏
#if WANSON_DUAL_MIC_ALGORITHM
        s16 temp = 0;
        for (u32 i = 0; i < ONCE_SR_POINTS; ++i) {
            temp = buf[3 * i + 1];
            buf[3 * i + 1] = buf[3 * i + 2];
            buf[3 * i + 2] = temp;
        }
#else
        s16 temp = 0;
        for (u32 i = 0; i < ONCE_SR_POINTS; ++i) {
            temp = buf[2 * i + 1];
            buf[2 * i + 1] = buf[2 * i];
            buf[2 * i] = temp;
        }
#endif
#endif

#endif

        if (1 == Wanson_ASR_Recog(buf, ONCE_SR_POINTS, &text, &score)) {
            printf("{ wakeup_word: %s}\n", text);
        }

#ifdef WIFI_PCM_STREAN_SOCKET_ENABLE
#if (WIFI_PCM_STREAN_TEST == PCM_TEST_MODE_0) && !DISABLE_AEC_CHANNEL
        short temp_buf[ONCE_SR_POINTS];
        extern void wifi_pcm_stream_socket_send(u8 * buf, u32 len);
        cbuf_read(&__this->aec_cbuf, temp_buf, sizeof(temp_buf));
        for (u32 i = 0; i < ONCE_SR_POINTS; ++i) {
#if WANSON_DUAL_MIC_ALGORITHM
            __this->send_buf[4 * i] = buf[3 * i];
            __this->send_buf[4 * i + 1] = buf[3 * i + 1];
            __this->send_buf[4 * i + 2] = buf[3 * i + 2];
            __this->send_buf[4 * i + 3] = temp_buf[i];
#else
            __this->send_buf[4 * i] = buf[2 * i];
            __this->send_buf[4 * i + 2] = buf[2 * i + 1];
            __this->send_buf[4 * i + 3] = temp_buf[i];
#endif
        }
        wifi_pcm_stream_socket_send((u8 *)__this->send_buf, sizeof(__this->send_buf));
#endif
#endif
    }

    Wanson_ASR_Release();
}

static void enc_server_event_handler(void *priv, int argc, int *argv)
{
    switch (argv[0]) {
    case AUDIO_SERVER_EVENT_ERR:
    case AUDIO_SERVER_EVENT_END:
        break;
    default:
        break;
    }
}

static int wanson_vfs_fwrite(void *file, void *data, u32 len)
{
    cbuffer_t *cbuf = (cbuffer_t *)file;

    u32 wlen = cbuf_write(cbuf, data, len);
    if (wlen != len) {
        cbuf_clear(&__this->mic_cbuf);
#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
        cbuf_clear(&__this->linein_cbuf);
#endif
#if defined WIFI_PCM_STREAN_SOCKET_ENABLE && !DISABLE_AEC_CHANNEL
        cbuf_clear(&__this->aec_cbuf);
#endif
        puts("busy!\n");
    }
    if (file == (void *)&__this->mic_cbuf) {
        os_sem_set(&__this->sem, 0);
        os_sem_post(&__this->sem);
    }

    return len;
}

static int wanson_vfs_fclose(void *file)
{
    return 0;
}

static const struct audio_vfs_ops wanson_vfs_ops = {
    .fwrite = wanson_vfs_fwrite,
    .fclose = wanson_vfs_fclose,
};

#if !defined CONFIG_NO_SDRAM_ENABLE && !DISABLE_AEC_CHANNEL
u32 asr_read_input(u8 *buf, u32 len)
{
    u32 rlen = 0;

    do {
        if (!__this->run_flag) {
            return 0;
        }
        rlen = cbuf_read(&__this->asr_cbuf, buf, len);
        if (rlen == len) {
            break;
        }
        os_sem_pend(&__this->asr_sem, 0);
    } while (!rlen);

    return rlen;
}
#endif

void *get_asr_read_input_cb(void)
{
    if (!__this->run_flag) {
        return NULL;
    }

#if !defined CONFIG_NO_SDRAM_ENABLE && !DISABLE_AEC_CHANNEL
    os_sem_set(&__this->asr_sem, 0);
    cbuf_clear(&__this->asr_cbuf);
    return (void *)&asr_read_input;
#else
    return NULL;
#endif
}

int aisp_open(u16 sample_rate)
{
    union audio_req req = {0};

    __this->mic_enc = server_open("audio_server", "enc");
    if (!__this->mic_enc) {
        goto __err;
    }

#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
    __this->linein_enc = server_open("audio_server", "enc");
    if (!__this->linein_enc) {
        goto __err;
    }
#endif

    server_register_event_handler(__this->mic_enc, NULL, enc_server_event_handler);
    cbuf_init(&__this->mic_cbuf, __this->mic_buf, sizeof(__this->mic_buf));
#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
    server_register_event_handler(__this->linein_enc, NULL, enc_server_event_handler);
    cbuf_init(&__this->linein_cbuf, __this->linein_buf, sizeof(__this->linein_buf));
#endif
#if defined WIFI_PCM_STREAN_SOCKET_ENABLE && !DISABLE_AEC_CHANNEL
    cbuf_init(&__this->aec_cbuf, __this->aec_buf, sizeof(__this->aec_buf));
#endif
#if !defined CONFIG_NO_SDRAM_ENABLE && !DISABLE_AEC_CHANNEL
    cbuf_init(&__this->asr_cbuf, __this->asr_buf, sizeof(__this->asr_buf));
    os_sem_create(&__this->asr_sem, 0);
#endif

    os_sem_create(&__this->sem, 0);

    thread_fork("wanson", 3, 1024, 0, &__this->pid, wanson_task, __this);

    req.enc.cmd = AUDIO_ENC_OPEN;

#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
#if WANSON_DUAL_MIC_ALGORITHM
    req.enc.channel = 2;
    req.enc.channel_bit_map = BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL);
#else
    req.enc.channel = 1;
    req.enc.channel_bit_map = BIT(CONFIG_AISP_MIC0_ADC_CHANNEL);
#endif
#else
#if WANSON_DUAL_MIC_ALGORITHM
    req.enc.channel = DISABLE_AEC_CHANNEL ? 2 : 3;
    req.enc.channel_bit_map = DISABLE_AEC_CHANNEL ? BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL) : \
                              BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL) | BIT(CONFIG_AISP_LINEIN_ADC_CHANNEL);
#else
    req.enc.channel = DISABLE_AEC_CHANNEL ? 1 : 2;
    req.enc.channel_bit_map = DISABLE_AEC_CHANNEL ? BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) : BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL);
#endif
#endif
    req.enc.frame_size = ONCE_SR_POINTS * 2 * req.enc.channel;
    req.enc.volume = CONFIG_AISP_MIC_ADC_GAIN;
    req.enc.sample_rate = sample_rate;
    req.enc.format = "pcm";
#if CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_PLNK0
    req.enc.sample_source = "plnk0";
#elif CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_PLNK1
    req.enc.sample_source = "plnk1";
#elif CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_IIS0
    req.enc.sample_source = "iis0";
#elif CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_IIS1
    req.enc.sample_source = "iis1";
#else
    req.enc.sample_source = "mic";
#endif
    req.enc.vfs_ops = &wanson_vfs_ops;
    req.enc.output_buf_len = req.enc.frame_size * 3;
    req.enc.file = (FILE *)&__this->mic_cbuf;

    server_request(__this->mic_enc, AUDIO_REQ_ENC, &req);

#if defined CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
#if !DISABLE_AEC_CHANNEL
    extern void adc_multiplex_set_gain(const char *source, u8 channel_bit_map, u8 gain);
    adc_multiplex_set_gain("mic", BIT(CONFIG_AISP_LINEIN_ADC_CHANNEL), CONFIG_AISP_LINEIN_ADC_GAIN);
#endif
#else
    memset(&req, 0, sizeof(req));

    req.enc.cmd = AUDIO_ENC_OPEN;
    req.enc.channel = 1;
    req.enc.volume = CONFIG_AISP_LINEIN_ADC_GAIN;
    req.enc.sample_rate = sample_rate;
    req.enc.format = "pcm";
    req.enc.frame_size = ONCE_SR_POINTS * 2;
#ifdef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN_OTHER
    req.enc.sample_source = "mic";	//使用数字MIC且用差分MIC做回采时需要打开这个
#else
    req.enc.sample_source = "linein";
#endif
    req.enc.vfs_ops = &wanson_vfs_ops;
    req.enc.output_buf_len = req.enc.frame_size * 3;
    req.enc.channel_bit_map = BIT(CONFIG_AISP_LINEIN_ADC_CHANNEL);
    req.enc.file = (FILE *)&__this->linein_cbuf;

    server_request(__this->linein_enc, AUDIO_REQ_ENC, &req);
#endif

    __this->sample_rate = sample_rate;
    __this->run_flag = 1;
    os_sem_post(&__this->sem);

    return 0;

__err:
    if (__this->mic_enc) {
        server_close(__this->mic_enc);
        __this->mic_enc = NULL;
    }
#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
    if (__this->linein_enc) {
        server_close(__this->linein_enc);
        __this->linein_enc = NULL;
    }
#endif

    return -1;
}

void aisp_suspend(void)
{
    union audio_req req = {0};

    __this->run_flag = 0;

#if !defined CONFIG_NO_SDRAM_ENABLE && !DISABLE_AEC_CHANNEL
    os_sem_post(&__this->asr_sem);
#endif

    req.enc.cmd = AUDIO_ENC_STOP;
    server_request(__this->mic_enc, AUDIO_REQ_ENC, &req);
    cbuf_clear(&__this->mic_cbuf);
#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
    server_request(__this->linein_enc, AUDIO_REQ_ENC, &req);
    cbuf_clear(&__this->linein_cbuf);
#endif
}

void aisp_resume(void)
{
    union audio_req req = {0};

#if defined WIFI_PCM_STREAN_SOCKET_ENABLE && !DISABLE_AEC_CHANNEL
    cbuf_clear(&__this->aec_cbuf);
#endif

    Wanson_ASR_Reset();

    __this->run_flag = 1;
    os_sem_set(&__this->sem, 0);
    os_sem_post(&__this->sem);

    req.enc.cmd = AUDIO_ENC_OPEN;
#ifndef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
#if WANSON_DUAL_MIC_ALGORITHM
    req.enc.channel = 2;
    req.enc.channel_bit_map = BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL);
#else
    req.enc.channel = 1;
    req.enc.channel_bit_map = BIT(CONFIG_AISP_MIC0_ADC_CHANNEL);
#endif
#else
#if WANSON_DUAL_MIC_ALGORITHM
    req.enc.channel = DISABLE_AEC_CHANNEL ? 2 : 3;
    req.enc.channel_bit_map = DISABLE_AEC_CHANNEL ? BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL) : \
                              BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL) | BIT(CONFIG_AISP_LINEIN_ADC_CHANNEL);
#else
    req.enc.channel = DISABLE_AEC_CHANNEL ? 1 : 2;
    req.enc.channel_bit_map = DISABLE_AEC_CHANNEL ? BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) : BIT(CONFIG_AISP_MIC0_ADC_CHANNEL) | BIT(CONFIG_AISP_MIC1_ADC_CHANNEL);
#endif
#endif
    req.enc.frame_size = ONCE_SR_POINTS * 2 * req.enc.channel;
    req.enc.volume = CONFIG_AISP_MIC_ADC_GAIN;
    req.enc.sample_rate = __this->sample_rate;
    req.enc.format = "pcm";
#if CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_PLNK0
    req.enc.sample_source = "plnk0";
#elif CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_PLNK1
    req.enc.sample_source = "plnk1";
#elif CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_IIS0
    req.enc.sample_source = "iis0";
#elif CONFIG_AUDIO_ENC_SAMPLE_SOURCE == AUDIO_ENC_SAMPLE_SOURCE_IIS1
    req.enc.sample_source = "iis1";
#else
    req.enc.sample_source = "mic";
#endif
    req.enc.vfs_ops = &wanson_vfs_ops;
    req.enc.output_buf_len = req.enc.frame_size * 3;
    req.enc.file = (FILE *)&__this->mic_cbuf;

    server_request(__this->mic_enc, AUDIO_REQ_ENC, &req);

#if defined CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN
#if !DISABLE_AEC_CHANNEL
    extern void adc_multiplex_set_gain(const char *source, u8 channel_bit_map, u8 gain);
    adc_multiplex_set_gain("mic", BIT(CONFIG_AISP_LINEIN_ADC_CHANNEL), CONFIG_AISP_LINEIN_ADC_GAIN);
#endif
#else
    memset(&req, 0, sizeof(req));

    req.enc.cmd = AUDIO_ENC_OPEN;
    req.enc.channel = 1;
    req.enc.volume = CONFIG_AISP_LINEIN_ADC_GAIN;
    req.enc.sample_rate = __this->sample_rate;
    req.enc.format = "pcm";
    req.enc.frame_size = ONCE_SR_POINTS * 2;
#ifdef CONFIG_WANSON_DIFFER_MIC_REPLACE_LINEIN_OTHER
    req.enc.sample_source = "mic";	//使用数字MIC且用差分MIC做回采时需要打开这个
#else
    req.enc.sample_source = "linein";
#endif
    req.enc.vfs_ops = &wanson_vfs_ops;
    req.enc.output_buf_len = req.enc.frame_size * 3;
    req.enc.channel_bit_map = BIT(CONFIG_AISP_LINEIN_ADC_CHANNEL);
    req.enc.file = (FILE *)&__this->linein_cbuf;

    server_request(__this->linein_enc, AUDIO_REQ_ENC, &req);
#endif
}

#endif
